<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大黄的博客</title>
  
  <subtitle>我的动力源泉</subtitle>
  <link href="http://bighuang.fun/atom.xml" rel="self"/>
  
  <link href="http://bighuang.fun/"/>
  <updated>2023-04-22T14:09:29.818Z</updated>
  <id>http://bighuang.fun/</id>
  
  <author>
    <name>黄和霖</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二分查找</title>
    <link href="http://bighuang.fun/2023/04/22/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://bighuang.fun/2023/04/22/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2023-04-22T13:58:23.000Z</published>
    <updated>2023-04-22T14:09:29.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p><font face="正楷" size=4>坚持每天更新博客，今天复习二分查找</font></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h1><p><font face="正楷" size=4>二分查找相较于普通的查找的时间复杂度更小，为O（logn）。</p><p>二分查找主要针对一段单调的区间，然后将区间分为左右两个部分，通过判断不断缩小范围直到找到答案。</font></p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><font face="正楷" size=4>其实模板1和模板2本质上是根据代码来区分的，而不是应用场景。如果写完之后发现是l = mid，那么在计算mid时需要加上1，否则如果写完之后发现是r = mid，那么在计算mid时不能加1。</font></p><h3 id="版本一"><a href="#版本一" class="headerlink" title="版本一:"></a>版本一:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int bsearch_1(int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r &gt;&gt; 1;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int bsearch_2(int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r + 1 &gt;&gt; 1;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;正楷&quot; size=4&gt;坚持每天更新博客，今天复习二分查找&lt;/font&gt;&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="算法" scheme="http://bighuang.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="查找" scheme="http://bighuang.fun/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>Educational Codeforces Round 147 (Rated for Div. 2) A - C</title>
    <link href="http://bighuang.fun/2023/04/21/C/"/>
    <id>http://bighuang.fun/2023/04/21/C/</id>
    <published>2023-04-21T13:52:01.000Z</published>
    <updated>2023-04-21T13:58:11.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CF1821-A-Matching"><a href="#CF1821-A-Matching" class="headerlink" title="CF1821 A Matching"></a>CF1821 A Matching</h1><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">using LL = long long;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    ios::sync_with_stdio(0);</span><br><span class="line"></span><br><span class="line">    const int pow10[] = &#123;1, 10, 100, 1000, 10000, 100000&#125;;</span><br><span class="line"></span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s[0] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">0 &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="string">            continue;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        int cnt = count(s.begin(), s.end(), &#x27;?&#x27;);</span></span><br><span class="line"><span class="string">        if (s[0</span>] == <span class="string">&#x27;?&#x27;</span>) cout &lt;&lt; <span class="string">9 * pow10[cnt - 1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="string">        else cout &lt;&lt; pow10[cnt] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="CF1821-B-Sort-the-Subarray"><a href="#CF1821-B-Sort-the-Subarray" class="headerlink" title="CF1821 B Sort the Subarray"></a>CF1821 B Sort the Subarray</h1><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">using LL = long long;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    ios::sync_with_stdio(0);</span><br><span class="line"></span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        vector&lt;int&gt; a(n + 1), b(n + 1);</span><br><span class="line">        vector&lt;int&gt; pre(n + 2), suf(n + 2);</span><br><span class="line">        <span class="keyword">for</span>(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">for</span>(int i = 1; i &lt;= n; i++) cin &gt;&gt; b[i];</span><br><span class="line">        pre[0] = suf[n + 1] = 1;</span><br><span class="line">        <span class="keyword">for</span>(int i = 1; i &lt;= n; i++) </span><br><span class="line">            pre[i] = suf[i] = (a[i] == b[i]);</span><br><span class="line">        <span class="keyword">for</span>(int i = 1; i &lt;= n; i++)</span><br><span class="line">            pre[i] &amp;= pre[i - 1];</span><br><span class="line">        <span class="keyword">for</span>(int i = n; i &gt;= 1; i--) </span><br><span class="line">            suf[i] &amp;= suf[i + 1];</span><br><span class="line">        int l = 0, r = -1;</span><br><span class="line">        <span class="keyword">for</span>(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            int j = i;</span><br><span class="line">            <span class="keyword">while</span>(j + 1 &lt;= n &amp;&amp; b[j + 1] &gt;= b[j]) j++;</span><br><span class="line">            <span class="keyword">if</span> (pre[i - 1] &amp;&amp; suf[j + 1] &amp;&amp; j - i + 1 &gt; r - l + 1)&#123;</span><br><span class="line">                l = i, r = j;</span><br><span class="line">            &#125;</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="CF12821C-Tear-It-Apart"><a href="#CF12821C-Tear-It-Apart" class="headerlink" title="CF12821C Tear It Apart"></a>CF12821C Tear It Apart</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><font face="正楷" size=4>先预处理出来所有长度的序列需要多少步才能清空,然后枚举最后剩的字母计算答案即可,显然操作的数量之和同字母之间的最长距离有关.</p><p>代码实现</font></p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">using LL = long long;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    ios::sync_with_stdio(0);</span><br><span class="line"></span><br><span class="line">    const int N = 2e5;</span><br><span class="line">    vector&lt;int&gt; f(N + 1);</span><br><span class="line">    <span class="keyword">for</span>(int i = 1; i &lt;= N; i++)</span><br><span class="line">        f[i] = f[i / 2] + 1;</span><br><span class="line"></span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; pos(26, &#123;-1&#125;);</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(int i = 0; i &lt; s.size(); i++)&#123;</span><br><span class="line">            int c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            pos[c].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = s.size();</span><br><span class="line">        <span class="keyword">for</span>(auto &amp;v : pos)&#123;</span><br><span class="line">            v.push_back(s.size());</span><br><span class="line">            int res = 0;</span><br><span class="line">            <span class="keyword">for</span>(int i = 1; i &lt; v.size(); i++)&#123;</span><br><span class="line">                int len = v[i] - v[i - 1] - 1;</span><br><span class="line">                res = max(res, f[len]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = min(ans, res);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">ans &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CF1821-A-Matching&quot;&gt;&lt;a href=&quot;#CF1821-A-Matching&quot; class=&quot;headerlink&quot; title=&quot;CF1821 A Matching&quot;&gt;&lt;/a&gt;CF1821 A Matching&lt;/h1&gt;&lt;h2 id=&quot;代码实现&quot;</summary>
      
    
    
    
    <category term="刷题" scheme="http://bighuang.fun/categories/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="codeforce" scheme="http://bighuang.fun/tags/codeforce/"/>
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="http://bighuang.fun/2023/04/20/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>http://bighuang.fun/2023/04/20/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2023-04-20T10:45:33.000Z</published>
    <updated>2023-04-20T12:16:11.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p><font face="正楷" size=4>时隔两天再次写起了博客，最近学习积极性越来越低迷了。</p><p>为了我的未来，一定要变得自律起来。废话不多说，今天复习的内容是单调栈</font></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h1><p><font face="正楷" size=4>单调栈一般用于解决与下一个更大元素（有关的问题，包括以下几类：</p><p>1.寻找每个元素的下一个更大元素。<br>2.寻找每个元素的下一个更大或相等元素。<br>3.寻找每个元素的下一个更小元素或更小或相等元素。<br>在这些问题中，单调栈维护一个单调递增或递减的栈，将元素依次压入栈中。对于每个新元素，我们可以在栈中弹出所有比它小的元素，并将它们的“下一个更大/小元素”设置为当前元素。</font></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p><font face="正楷" size=4>直接上一道牛客偏难的题目，当初没想到用单调栈解决</font></p><h2 id="题目-最优屏障"><a href="#题目-最优屏障" class="headerlink" title="题目:最优屏障"></a>题目:<a href="https://ac.nowcoder.com/acm/problem/14666">最优屏障</a></h2><p><font face="正楷" size=4>M国的地势高低不平，现给出一个数组代表此国家某纬度上均匀分布的N座山的海拔高度H<a href="%E4%BB%BB%E6%84%8F%E4%B8%A4%E5%BA%A7%E5%B1%B1%E9%AB%98%E5%BA%A6%E4%B8%8D%E5%90%8C">i</a>，已知每座山的山顶上都有一座哨塔，若两个哨兵分别位于第i、j(i&lt;j)座山上，当且仅当两人所在的山比两人之间所有的山都高时，这两个哨兵可以相互监视，M国的防守能力大小为相互监视的哨兵对数。H国早已对M国虎视眈眈，H国的皇帝希望黑魔法师们可以在M国的某两座山之间放置一块巨大的屏障,M国的哨兵不可通过该屏障互相监视。皇帝想让你告诉他最优的屏障放置位置，你是皇帝手下最信任的军师，现在需要你帮助皇帝计算最优的屏障放置位置和最大的防守力减少量。</font></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><font face="正楷" size=4>维护一个栈分别计算第i座山左右两边能够守望的山数。又因为要计算放置最优屏障后最大防守力减少值，</p><p>所以只需要用最大防守力将去屏障两边的左右防守力，即第i个位置的左右两边的能到达的防守力。</p><p>所以我们不仅要算出第i坐山的防守力，同时还有两个前缀和数组（一个是从第1到第i的防守力，另一个是第i到第1的防守力）即可算出最优屏障左右两边减少的防守力<br></font></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N=5e5+5;</span><br><span class="line">int a[N],<span class="built_in">ln</span>[N],rn[N];</span><br><span class="line"></span><br><span class="line">void solve(int m)&#123;</span><br><span class="line">    int n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    memset(<span class="built_in">ln</span>,0,sizeof <span class="built_in">ln</span>);</span><br><span class="line">    memset(rn,0,sizeof rn);</span><br><span class="line">    stack&lt;int&gt;st;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">ln</span>[i]=<span class="built_in">ln</span>[i-1];</span><br><span class="line">        <span class="keyword">while</span>(st.size()&amp;&amp;st.top()&lt;a[i])</span><br><span class="line">            <span class="built_in">ln</span>[i]++,</span><br><span class="line">            st.pop();</span><br><span class="line">        <span class="keyword">if</span>(st.size())<span class="built_in">ln</span>[i]++;</span><br><span class="line">        st.push(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(st.size())st.pop();</span><br><span class="line">    <span class="keyword">for</span>(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">        rn[i]=rn[i+1];</span><br><span class="line">        <span class="keyword">while</span>(st.size()&amp;&amp;st.top()&lt;a[i])</span><br><span class="line">            rn[i]++,</span><br><span class="line">            st.pop();</span><br><span class="line">        <span class="keyword">if</span>(st.size())rn[i]++;</span><br><span class="line">        st.push(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    int ans=-1,idx=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int temp=<span class="built_in">ln</span>[n]-(<span class="built_in">ln</span>[i-1]+rn[i]);</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;ans)ans=temp,idx=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d %d\n&quot;</span>,m,idx,ans);</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    int T;cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(int m=1;m&lt;=T;m++)&#123;</span><br><span class="line">        solve(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;正楷&quot; size=4&gt;时隔两天再次写起了博客，最近学习积极性越来越低迷了。&lt;/p&gt;
&lt;p&gt;为了我的未来，一定要变</summary>
      
    
    
    
    <category term="算法" scheme="http://bighuang.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="解决寻找下一个更大或更小元素的问题" scheme="http://bighuang.fun/tags/%E8%A7%A3%E5%86%B3%E5%AF%BB%E6%89%BE%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E6%88%96%E6%9B%B4%E5%B0%8F%E5%85%83%E7%B4%A0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>倍增LCA</title>
    <link href="http://bighuang.fun/2023/04/17/%E5%80%8D%E5%A2%9ELCA/"/>
    <id>http://bighuang.fun/2023/04/17/%E5%80%8D%E5%A2%9ELCA/</id>
    <published>2023-04-17T13:14:01.000Z</published>
    <updated>2023-04-18T01:37:50.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p><font face="正楷" size=4>蓝桥杯前没有学到LCA，最后两题都用到了LCA。</p><p>无奈啊，今天补上这个</font></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h1><p><font face="正楷" size=4>LCA即在一棵树上，找到两个结点的最近祖先(祖先可能有多个)。</p><p>主要有两种算法解决，这里讲解一下倍增dp算法找到LCA。</p><p>其基本思想是通过预处理出每个节点距离2^k个祖先的信息，并利用这些信息在查询时快速跳转到两个节点的同一深度，然后再沿着祖先链进行比较，找到它们的LCA。</p><p>具体来说，倍增LCA算法分为两个步骤：预处理和查询。预处理阶段需要对整棵树进行遍历，计算出每个节点距离2^k个祖先的距离信息。查询阶段则利用这些信息，在O(logn)的时间内找到两个节点的LCA。</p><p>在预处理阶段，我们可以使用动态规划的方式，逐层计算出节点距离2^k个祖先的距离信息。具体来说，设f[i][j]表示节点i距离2^j个祖先的距离，那么有以下递推式：</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f[i][0] = fa[i]</span><br><span class="line">f[i][j] = f[f[i][j-1]][j-1] + f[i][j-1]</span><br></pre></td></tr></table></figure><p><font face="正楷" size=4>其中fa[i]表示节点i的父亲节点。可以看出，f[i][j]可以由f[i][j-1]和f[f[i][j-1]][j-1]计算得到。这也就是“倍增”的含义。通过这个递推式，我们可以在O(nlogn)的时间内预处理出所有节点距离2</font></p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p><font face="正楷" size=4>利用深搜处理这颗树，然后预处理每个节点的倍增数组</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void dfs(int u,int fa)&#123;</span><br><span class="line">    f[u][0]=fa,dep[u]=dep[fa]+1;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;(1&lt;&lt;<span class="string">i)&lt;=dep[u];i</span>++)f[u][i]=f[[f[u][i-1]]][i-1];</span><br><span class="line">    <span class="keyword">for</span>(auto &amp;p:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(p!=fa)</span><br><span class="line">            dfs(p,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p><font face="正楷" size=4>让深度大的结点向上跳跃(这里的跳跃是大跳跃)，直到同一深度。</p><p>然后两者同时跳,直到跳到同一结点结束(注意该节点不是LCA，应该是该节点的上面的第一个祖先才是LCA)</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int lca(int u,int v)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&lt;dep[v])swap(u,v);//挑选深度更大的结点先跳跃</span><br><span class="line">    <span class="keyword">for</span>(int i=20;i&gt;=0;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[f[u][i]]&gt;=dep[v])u=f[u][i];//判断是否同一深度</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u==v)<span class="built_in">return</span> u;//如果用一深度</span><br><span class="line">    <span class="keyword">for</span>(int i=20;i&gt;=0;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[u][i]!=f[v][i])u=f[u][i],v=f[v][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> f[u][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树上差分"><a href="#树上差分" class="headerlink" title="树上差分"></a>树上差分</h2><p><font face="正楷" size=4>讲完lca，这里补充一下树上差分。</p><p>任意树上两个结点的距离会等于$distance=dist[u]+dist[v]-2*lca(u,v)</p><p>即从根到u结点的距离+根到v结点的距离-2*根到二者lca的距离(画图秒懂)</font></p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p><font face="正楷" size=4>接下来直接上两道蓝桥杯真题，快速掌握lca以及树上差分</font></p><h2 id="题目一：蓝桥杯2023年第十四届省赛真题-砍树"><a href="#题目一：蓝桥杯2023年第十四届省赛真题-砍树" class="headerlink" title="题目一：蓝桥杯2023年第十四届省赛真题-砍树"></a>题目一：<a href="https://www.dotcpp.com/oj/problem3157.html">蓝桥杯2023年第十四届省赛真题-砍树</a></h2><p><font face="正楷" size=4>给定一棵由 n 个结点组成的树以及 m 个不重复的无序数对 (a1, b1), (a2, b2),. . . , (am, bm)，</p><p>其中 ai 互不相同，bi 互不相同，ai ≠ bj(1 ≤ i, j ≤ m)。</p><p>小明想知道是否能够选择一条树上的边砍断，使得对于每个 (ai , bi) 满足 ai和 bi 不连通，</p><p>如果可以则输出应该断掉的边的编号（编号按输入顺序从 1 开始），否则输出 -1.(完整题目点题目就可以)</font></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e5+5;</span><br><span class="line">vector&lt;pair&lt;int,int&gt;&gt;e[N];</span><br><span class="line">int dep[N],f[N][20],s[N],n,m,ans=-1;</span><br><span class="line">void init(int u,int fa)&#123;</span><br><span class="line">    dep[u]=dep[fa]+1;f[u][0]=fa;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;(1&lt;&lt;<span class="string">i)&lt;=dep[u];i</span>++)f[u][i]=f[f[u][i-1]][i-1];</span><br><span class="line">    <span class="keyword">for</span>(auto &amp;p:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.first!=fa)&#123;</span><br><span class="line">            init(p.first,u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int lca(int u,int v)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&lt;dep[v])swap(u,v);</span><br><span class="line">    <span class="keyword">for</span>(int i=20;i&gt;=0;i--)</span><br><span class="line">        <span class="keyword">if</span>(dep[f[u][i]]&gt;=dep[v])u=f[u][i];</span><br><span class="line">    <span class="keyword">if</span>(u==v)<span class="built_in">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(int i=20;i&gt;=0;i--)</span><br><span class="line">        <span class="keyword">if</span>(f[u][i]!=f[v][i])</span><br><span class="line">            u=f[u][i],v=f[v][i];</span><br><span class="line">    <span class="built_in">return</span> f[u][0];</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int u,int fa)&#123;</span><br><span class="line">    <span class="keyword">for</span>(auto &amp;p:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.first!=fa) &#123;</span><br><span class="line">            dfs(p.first, u);</span><br><span class="line">            s[u] += s[p.first];</span><br><span class="line">            <span class="keyword">if</span> (s[p.first] == m)</span><br><span class="line">                ans = max(ans, p.second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    ios::sync_with_stdio(0),cin.tie(0);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        int u,v;cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        e[u].push_back(&#123;v,i&#125;);</span><br><span class="line">        e[v].push_back(&#123;u,i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    init(1,0);</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int u,v;cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        s[u]+=1;s[v]+=1;s[lca(u,v)]-=2;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(1,0);</span><br><span class="line">    cout&lt;&lt;<span class="string">ans;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="题目二-蓝桥杯2023年第十四届省赛真题-景区导游"><a href="#题目二-蓝桥杯2023年第十四届省赛真题-景区导游" class="headerlink" title="题目二:蓝桥杯2023年第十四届省赛真题-景区导游"></a>题目二:<a href="https://www.dotcpp.com/oj/problem3156.html">蓝桥杯2023年第十四届省赛真题-景区导游</a></h2><p><font face="正楷" size=4>某景区一共有 N 个景点，编号 1 到 N。景点之间共有 N − 1 条双向的摆渡车线路相连，形成一棵树状结构。在景点之间往返只能通过这些摆渡车进行，需要花费一定的时间。<br>小明是这个景区的资深导游，他每天都要按固定顺序带客人游览其中 K 个景点：A1, A2, . . . , AK。今天由于时间原因，小明决定跳过其中一个景点，只带游客按顺序游览其中 K − 1 个景点。具体来说，如果小明选择跳过 Ai，那么他会按顺序带游客游览 A1, A2, . . . , Ai−1, Ai+1, . . . , AK, (1 ≤ i ≤ K)。<br>请你对任意一个 Ai，计算如果跳过这个景点，小明需要花费多少时间在景点之间的摆渡车上？(具体见题目)</font></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int N=1e5+5;</span><br><span class="line">vector&lt;pair&lt;int,int&gt;&gt;e[N];</span><br><span class="line">ll dep[N],f[N][21];</span><br><span class="line">ll dist[N];</span><br><span class="line"></span><br><span class="line">void dfs(int u,int fa,ll d)&#123;</span><br><span class="line">    dep[u]=dep[fa]+1,f[u][0]=fa,dist[u]=d;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;(1&lt;&lt;<span class="string">i)&lt;=dep[u];i</span>++)f[u][i]=f[f[u][i-1]][i-1];</span><br><span class="line">    <span class="keyword">for</span>(auto &amp;p:e[u])</span><br><span class="line">        <span class="keyword">if</span>(p.first!=fa)</span><br><span class="line">            dfs(p.first,u,d+p.second);</span><br><span class="line">&#125;</span><br><span class="line">int lca(int u,int v)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&lt;dep[v])swap(u,v);</span><br><span class="line">    <span class="keyword">for</span>(int i=20;i&gt;=0;i--)</span><br><span class="line">        <span class="keyword">if</span>(dep[f[u][i]]&gt;=dep[v])u=f[u][i];</span><br><span class="line">    <span class="keyword">if</span>(u==v)<span class="built_in">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(int i=20;i&gt;=0;i--)</span><br><span class="line">        <span class="keyword">if</span>(f[u][i]!=f[v][i])u=f[u][i],v=f[v][i];</span><br><span class="line">    <span class="built_in">return</span> f[u][0];</span><br><span class="line">&#125;</span><br><span class="line">ll get(int u,int v)&#123;</span><br><span class="line">    <span class="built_in">return</span> dist[u]+dist[v]-2*dist[lca(u,v)];</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    int n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        int u,v,t;cin&gt;&gt;u&gt;&gt;v&gt;&gt;t;</span><br><span class="line">        e[u].push_back(&#123;v,t&#125;);</span><br><span class="line">        e[v].push_back(&#123;u,t&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt;a(k);</span><br><span class="line">    <span class="keyword">for</span>(auto&amp;p:a)cin&gt;&gt;p;</span><br><span class="line">    dfs(1,0,0);</span><br><span class="line">    ll <span class="built_in">sum</span>=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;k;i++)<span class="built_in">sum</span>+=get(a[i-1],a[i]);</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">        ll ans=<span class="built_in">sum</span>;</span><br><span class="line">        <span class="keyword">if</span>(i!=0)ans-=(get(a[i],a[i-1]));</span><br><span class="line">        <span class="keyword">if</span>(i!=k-1)ans-=(get(a[i],a[i+1]));</span><br><span class="line">        <span class="keyword">if</span>(i!=0&amp;&amp;i!=k-1)ans+=get(a[i-1],a[i+1]);</span><br><span class="line">        cout&lt;&lt;<span class="string">ans&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;正楷&quot; size=4&gt;蓝桥杯前没有学到LCA，最后两题都用到了LCA。&lt;/p&gt;
&lt;p&gt;无奈啊，今天补上这个&lt;/f</summary>
      
    
    
    
    <category term="算法" scheme="http://bighuang.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="最近公共祖先" scheme="http://bighuang.fun/tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="http://bighuang.fun/2023/04/04/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://bighuang.fun/2023/04/04/%E7%BA%BF%E6%AE%B5%E6%A0%91/</id>
    <published>2023-04-04T11:30:38.000Z</published>
    <updated>2023-04-04T13:45:43.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p><font face="正楷" size=4>好久没更新我的博客了，最近变得好懈怠了。我收回之前说的话，蓝桥杯过后有icpc等着我，算法是要继续学的。</p><p>学算法感觉成就感挺高的，虽然很难也需要天赋，但是我会继续坚持下去的，加油。</p><p>当询问一段区间的和你可能会想到前缀和处理。当修改一段区间的值或只修改数组一个值，你可能会想到差分。</p><p>那么问题便来了，我若都要进行，而且操作很多次呢，是不是前缀和的处理以及差分处理会变得十分无助且无用。</p><p>所以接下来我们将用一个新的数据结<strong>线段树</strong>解决这些问题。</font></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h1><p><font face="正楷" size=4>线段树是一种基于树形结构实现的数据结构，主要用于高效处理区间查询问题。</p><p>具体而言，线段树可以对一个固定大小的数组进行预处理，用于支持多次对其中某个区间的查询和更新操作。线段树的叶子节点对应于数组中的单个元素，而非叶子节点代表了若干个元素的区间。</p><p>在处理区间查询问题时，可以通过操作线段树上与查询区间相交的结点，并将这些结点的信息组合起来得到查询结果。在处理区间更新操作时，可以通过操作线段树上与更新区间相交的结点，并将这些结点的信息更新、传递得到更新结果。</p><p>因此，线段树主要被用于处理具有区间查询和区间更新操作的数据结构，如动态数组、序列、链表、二维矩阵等。经过优化的线段树能够在 O(logn)的时间内进行单次查询和更新操作，具有较高的时空效率。</font></p><p><font face="正楷" size=4>线段树常见的模板:</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN=100005;</span><br><span class="line">int a[MAXN];</span><br><span class="line">struct Node&#123;</span><br><span class="line">    int l,r,tag;//l，r表示该节点表示的若干元素的区间，tag用来记录修改的值</span><br><span class="line">    ll <span class="built_in">sum</span>,mx;//sum为子孙的和，mx为区间的最大值。</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="string">2];//线段树大小开到数组的四倍</span></span><br><span class="line"><span class="string">inline int tl(int p)&#123;return p&lt;&lt;1;&#125;//左孩子</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">inline int tr(int p)&#123;return p&lt;&lt;1|1;&#125;//右孩子</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">inline void push_up(int p)&#123;//将p底下的子孙的值总和起来</span></span><br><span class="line"><span class="string">    tree[p].sum=tree[tl(p)].sum+tree[tr(p)].sum;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">inline void push_down(int p)&#123;//将p的tag修改值传递下去，同时子孙的数据也要改变</span></span><br><span class="line"><span class="string">    if(tree[p].tag)&#123;//如果p更新过数据</span></span><br><span class="line"><span class="string">        int tag=tree[p].tag;</span></span><br><span class="line"><span class="string">        tree[p].tag=0;</span></span><br><span class="line"><span class="string">        tree[tl(p)].tag+=tag;</span></span><br><span class="line"><span class="string">        tree[tr(p)].tag+=tag;</span></span><br><span class="line"><span class="string">        tree[tl(p)].mx+=tag;</span></span><br><span class="line"><span class="string">        tree[tr(p)].mx+=tag;</span></span><br><span class="line"><span class="string">        tree[tl(p)].sum+=(tree[tl(p)].r-tree[tl(p)].l+1)*tag;</span></span><br><span class="line"><span class="string">        tree[tr(p)].sum+=(tree[tr(p)].r-tree[tr(p)].l+1)*tag;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">void build(int p,int l,int r)&#123;//建立线段树</span></span><br><span class="line"><span class="string">    tree[p].l=l,tree[p].r=r;</span></span><br><span class="line"><span class="string">    if(l==r)&#123;</span></span><br><span class="line"><span class="string">        tree[p].sum=a[l];</span></span><br><span class="line"><span class="string">        tree[p].mx=a[l];</span></span><br><span class="line"><span class="string">        return;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    int mid=(l+r)&gt;&gt;1;</span></span><br><span class="line"><span class="string">    build(tl(p),l,mid);//建立左树</span></span><br><span class="line"><span class="string">    build(tr(p),mid+1,r);//建立右树</span></span><br><span class="line"><span class="string">    push_up(p);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">void update(int p,int l,int r,int val)&#123;</span></span><br><span class="line"><span class="string">    if(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r)&#123;//如果有一段区间被包含在要修改的区间，直接进行修改，不需要从子树的左右子树找</span></span><br><span class="line"><span class="string">        tree[p].tag+=val;</span></span><br><span class="line"><span class="string">        tree[p].sum+=(tree[p].r-tree[p].l+1)*val;</span></span><br><span class="line"><span class="string">        tree[p].mx+=val;</span></span><br><span class="line"><span class="string">        return;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    push_down(p);//将更改的信息往子树传递</span></span><br><span class="line"><span class="string">    int mid=(tree[p].l+tree[p].r)&gt;&gt;1;</span></span><br><span class="line"><span class="string">    if(mid&gt;=l)update(tl(p),l,r,val);//如果区间与要修改的区间左边有交集，从左子树找</span></span><br><span class="line"><span class="string">    if(mid&lt;r)update(tr(p),l,r,val);//如果区间与要修改的区间右边有交集，从右子树找</span></span><br><span class="line"><span class="string">    push_up(p);//更新父亲</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">ll query_sum(int p,int l,int r)&#123;</span></span><br><span class="line"><span class="string">    if(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r)&#123;//如果该区间刚好在要查询的区间中直接返回sum</span></span><br><span class="line"><span class="string">        return tree[p].sum;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    push_down(p);//遍历子树时，要将tag的信息往下传</span></span><br><span class="line"><span class="string">    int mid=(tree[p].l+tree[p].r)&gt;&gt;1;</span></span><br><span class="line"><span class="string">    ll sum=0;</span></span><br><span class="line"><span class="string">    if(mid&gt;=l)sum+= query_sum(tl(p),l,r);//如果区间与要查询的区间左边有交集，从左子树找</span></span><br><span class="line"><span class="string">    if(mid&lt;r)sum+= query_sum(tr(p),l,r);//如果区间与要查询的区间右边有交集，从右子树找</span></span><br><span class="line"><span class="string">    return sum;//返回答案</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">ll query_max(int p,int l,int r)&#123;</span></span><br><span class="line"><span class="string">    if(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r)&#123;//如果该区间刚好在要查询的区间中直接返回mx</span></span><br><span class="line"><span class="string">        return tree[p].mx;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    push_down(p);//和上面的一样</span></span><br><span class="line"><span class="string">    int mid=(tree[p].l+tree[p].r)&gt;&gt;1;</span></span><br><span class="line"><span class="string">    ll res=0;</span></span><br><span class="line"><span class="string">    if(mid&gt;=l)res=res&gt; query_sum(tl(p),l,r)?res:query_sum(tl(p),l,r);//如果区间与要查询的区间左边有交集，从左子树找</span></span><br><span class="line"><span class="string">    if(mid&lt;r)res=res&gt;query_sum(tr(p),l,r)?res:res&gt;query_sum(tr(p),l,r);//如果区间与要查询的区间右边有交集，从右子树找</span></span><br><span class="line"><span class="string">    return res;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="题目-P3372-【模板】线段树-1"><a href="#题目-P3372-【模板】线段树-1" class="headerlink" title="题目:P3372 【模板】线段树 1"></a>题目:<a href="https://www.luogu.com.cn/problem/P3372">P3372 【模板】线段树 1</a></h2><p><font face="正楷" size=4>如题，已知一个数列，你需要进行下面两种操作：</p><ol><li>将某区间每一个数加上 <code>k</code>。</li><li>求出某区间每一个数的和。</li></ol><p>第一行包含两个整数 <code>n, m</code>，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 <code>n</code> 个用空格分隔的整数，其中第 <code>i</code> 个数字表示数列第 <code>i</code> 项的初始值。</p><p>接下来 <code>m</code> 行每行包含 <code>3</code> 或 <code>4</code> 个整数，表示一个操作，具体如下：</p><ol><li><code>1 x y k</code>：将区间 <code>[x, y]</code> 内每个数加上 <code>k</code>。</li><li><code>2 x y</code>：输出区间 <code>[x, y]</code> 内每个数的和。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN=100005;</span><br><span class="line">int a[MAXN];</span><br><span class="line">int n,m;</span><br><span class="line">struct Node&#123;</span><br><span class="line">    int l,r,tag;//l，r表示该节点表示的若干元素的区间，tag用来记录修改的值</span><br><span class="line">    ll <span class="built_in">sum</span>,mx;//sum为子孙的和，mx为区间的最大值。</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="string">2];//线段树大小开到数组的四倍</span></span><br><span class="line"><span class="string">inline int tl(int p)&#123;return p&lt;&lt;1;&#125;//左孩子</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">inline int tr(int p)&#123;return p&lt;&lt;1|1;&#125;//右孩子</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">inline void push_up(int p)&#123;//将p底下的子孙的值总和起来</span></span><br><span class="line"><span class="string">    tree[p].sum=tree[tl(p)].sum+tree[tr(p)].sum;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">inline void push_down(int p)&#123;//将p的tag修改值传递下去，同时子孙的数据也要改变</span></span><br><span class="line"><span class="string">    if(tree[p].tag)&#123;//如果p更新过数据</span></span><br><span class="line"><span class="string">        int tag=tree[p].tag;</span></span><br><span class="line"><span class="string">        tree[p].tag=0;</span></span><br><span class="line"><span class="string">        tree[tl(p)].tag+=tag;</span></span><br><span class="line"><span class="string">        tree[tr(p)].tag+=tag;</span></span><br><span class="line"><span class="string">        tree[tl(p)].mx+=tag;</span></span><br><span class="line"><span class="string">        tree[tr(p)].mx+=tag;</span></span><br><span class="line"><span class="string">        tree[tl(p)].sum+=(tree[tl(p)].r-tree[tl(p)].l+1)*tag;</span></span><br><span class="line"><span class="string">        tree[tr(p)].sum+=(tree[tr(p)].r-tree[tr(p)].l+1)*tag;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">void build(int p,int l,int r)&#123;//建立线段树</span></span><br><span class="line"><span class="string">    tree[p].l=l,tree[p].r=r;</span></span><br><span class="line"><span class="string">    if(l==r)&#123;</span></span><br><span class="line"><span class="string">        tree[p].sum=a[l];</span></span><br><span class="line"><span class="string">        tree[p].mx=a[l];</span></span><br><span class="line"><span class="string">        return;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    int mid=(l+r)&gt;&gt;1;</span></span><br><span class="line"><span class="string">    build(tl(p),l,mid);//建立左树</span></span><br><span class="line"><span class="string">    build(tr(p),mid+1,r);//建立右树</span></span><br><span class="line"><span class="string">    push_up(p);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">void modify(int p,int l,int r,int val)&#123;</span></span><br><span class="line"><span class="string">    if(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r)&#123;//如果有一段区间被包含在要修改的区间，直接进行修改，不需要从子树的左右子树找</span></span><br><span class="line"><span class="string">        tree[p].tag+=val;</span></span><br><span class="line"><span class="string">        tree[p].sum+=(tree[p].r-tree[p].l+1)*val;</span></span><br><span class="line"><span class="string">        tree[p].mx+=val;</span></span><br><span class="line"><span class="string">        return;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    push_down(p);//将更改的信息往子树传递</span></span><br><span class="line"><span class="string">    int mid=(tree[p].l+tree[p].r)&gt;&gt;1;</span></span><br><span class="line"><span class="string">    if(mid&gt;=l)modify(tl(p),l,r,val);//如果区间与要修改的区间左边有交集，从左子树找</span></span><br><span class="line"><span class="string">    if(mid&lt;r)modify(tr(p),l,r,val);//如果区间与要修改的区间右边有交集，从右子树找</span></span><br><span class="line"><span class="string">    push_up(p);//更新父亲</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">ll query_sum(int p,int l,int r)&#123;</span></span><br><span class="line"><span class="string">    if(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r)&#123;//如果该区间刚好在要查询的区间中直接返回sum</span></span><br><span class="line"><span class="string">        return tree[p].sum;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    push_down(p);//遍历子树时，要将tag的信息往下传</span></span><br><span class="line"><span class="string">    int mid=(tree[p].l+tree[p].r)&gt;&gt;1;</span></span><br><span class="line"><span class="string">    ll sum=0;</span></span><br><span class="line"><span class="string">    if(mid&gt;=l)sum+= query_sum(tl(p),l,r);//如果区间与要查询的区间左边有交集，从左子树找</span></span><br><span class="line"><span class="string">    if(mid&lt;r)sum+= query_sum(tr(p),l,r);//如果区间与要查询的区间右边有交集，从右子树找</span></span><br><span class="line"><span class="string">    return sum;//返回答案</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main() &#123;</span></span><br><span class="line"><span class="string">    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);</span></span><br><span class="line"><span class="string">    for (int i = 1; i &lt;= n; ++i) &#123;</span></span><br><span class="line"><span class="string">        scanf(&quot;%lld&quot;, &amp;a[i]);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    build(1, 1, n);</span></span><br><span class="line"><span class="string">    while (m--) &#123;</span></span><br><span class="line"><span class="string">        int op, l, r, k;</span></span><br><span class="line"><span class="string">        scanf(&quot;%d %d %d&quot;, &amp;op, &amp;l, &amp;r);</span></span><br><span class="line"><span class="string">        if (op == 1) &#123;</span></span><br><span class="line"><span class="string">            scanf(&quot;%d&quot;, &amp;k);</span></span><br><span class="line"><span class="string">            modify(1, l, r, k);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        else &#123;</span></span><br><span class="line"><span class="string">            printf(&quot;%lld\n&quot;, query_sum(1, l, r));</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;正楷&quot; size=4&gt;好久没更新我的博客了，最近变得好懈怠了。我收回之前说的话，蓝桥杯过后有icpc等着我，算法</summary>
      
    
    
    
    <category term="数据结构" scheme="http://bighuang.fun/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="高效处理区间查询问题" scheme="http://bighuang.fun/tags/%E9%AB%98%E6%95%88%E5%A4%84%E7%90%86%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>SPFA算法</title>
    <link href="http://bighuang.fun/2023/03/30/SPFA/"/>
    <id>http://bighuang.fun/2023/03/30/SPFA/</id>
    <published>2023-03-30T07:39:29.000Z</published>
    <updated>2023-03-30T14:15:12.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p><font face="正楷" size=4>今天复习这个算法十分犹豫，大家都说<strong>spfa算法</strong>已死，即在比赛中容易被卡常。</p><p>但是大多数情况下用在存在负权边还是可以的，而且还能判断是否存在负权环，只能说该算法的优点远远大于缺点。</p><p><del>所以我是坚决不会用它的</del></font></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h1><p><font face="正楷" size=4>1.spfa在Bellman-Ford算法的基础上，利用队列来进行时间优化的一种可用于解决负边权判断负环的最短路算法。</p><p>2.spfa实际上就是先将起始点放入队列中，每次取出一个点，利用这个点将其周围的（与其相连的）点进行优化，如果某点有过松弛，就入队，重复这样的过程直到队列为空。但需要记录进队次数，如果一个点入队次数多于n次，即说明存在负环，则返回负环的结果。</p><p>3.判断是否存在负环时，只需要加一个数组time，来表示每个点入队的次数，当大于n时，执行关于负环的操作即可。</p><p>4.spfa时间复杂度一般为O(km)，k为一个常数，m为边的个数（当然可以创造出卡spfa的数据使其变为O(nm)），所以没有负权值的情况下优先考虑其他最短路算法。</font></p><p><font face="正楷" size=4><strong>常见的模板</strong>（这里用邻接表）</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int <span class="function"><span class="title">spfa</span></span>()&#123;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    memset(dist,0x3f,sizeof dist);</span><br><span class="line">    dist[1]=0;//初始化源点</span><br><span class="line">    q.emplace(dist[1],1);//first存放目前到源点的最短距离（该距离可被更新），second存放索引</span><br><span class="line">    st[1]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">        PII p=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        int t=p.second;</span><br><span class="line">        st[t]=<span class="literal">false</span>;//从队列中取出来之后该节点st被标记为<span class="literal">false</span>,代表之后该节点如果发生更新可再次入队</span><br><span class="line">        <span class="keyword">for</span>(int i=h[t];i!=-1;i=ne[i])&#123;</span><br><span class="line">            int j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])&#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;//当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                    q.emplace(dist[j],j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n]==0x3f3f3f3f) <span class="built_in">return</span> -1;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="题目：采购特价商品"><a href="#题目：采购特价商品" class="headerlink" title="题目：采购特价商品"></a>题目：<a href="https://www.luogu.com.cn/problem/P1744">采购特价商品</a></h2><p><font face="正楷" size=4>中山路店山店海，成了购物狂爱与愁大神的“不归之路”。中山路上有 n(n≤100）家店，每家店的坐标均在-10000与10000之间，其中m 家店之间有通路。若有通路，则表示可以从一家店走到另一家店，通路的距离为两点间的直线距离。现在爱与愁大神要找出从一家店到另一家店之间的最短距离。你能帮爱与愁大神算出吗？</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N=105;</span><br><span class="line">bool st[N];</span><br><span class="line">double dist[N],g[N][N];</span><br><span class="line">int x[N],y[N];</span><br><span class="line">int n,m;</span><br><span class="line">int s,e;</span><br><span class="line">long long sqr(int x)&#123;</span><br><span class="line">    <span class="built_in">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line">void ad(int u,int v)&#123;</span><br><span class="line">    long long b = (x[v]-x[u])*(x[v]-x[u])+(y[v]-y[u])*(y[v]-y[u]);</span><br><span class="line">    double a=sqrt(b);</span><br><span class="line">    g[u][v]=a;</span><br><span class="line">    g[v][u]=a;</span><br><span class="line">&#125;</span><br><span class="line">void spfa(int s)&#123;</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    dist[s] = 0;</span><br><span class="line">    st[s] = 1;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        st[now] = 0;</span><br><span class="line">        <span class="keyword">for</span>(int i = 1; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[i]&gt;g[now][i]+dist[now])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[i] =g[now][i]+dist[now];</span><br><span class="line">                <span class="keyword">if</span>(!st[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(i);</span><br><span class="line">                    st[i] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    memset(g,0x7f,sizeof g);</span><br><span class="line">    memset(dist,0x7f,sizeof dist);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        ad(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;e;</span><br><span class="line">    spfa(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>,dist[e]);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;正楷&quot; size=4&gt;今天复习这个算法十分犹豫，大家都说&lt;strong&gt;spfa算法&lt;/strong&gt;已死，即在</summary>
      
    
    
    
    <category term="算法" scheme="http://bighuang.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="单源最短路问题" scheme="http://bighuang.fun/tags/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="http://bighuang.fun/2023/03/29/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>http://bighuang.fun/2023/03/29/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</id>
    <published>2023-03-29T12:27:28.000Z</published>
    <updated>2023-03-29T13:39:15.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p><font face="正楷" size=4>蓝桥杯的时间快到了，我全心学习算法的日子快到头了，其实学习算法还是挺好玩的。</p><p>言归正传，今日浅浅地复习一下<strong>拓扑排序</strong>，还是挺容易的，只要明白其内涵便可以快速AC。</font></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h1><p><font face="黑体" size=4>拓扑排序主要用来解决有向图中的依赖解析问题。</p><p>即：对于任何有向图而言，其拓扑排序为其所有节点的一个线性排序(对于同一个有向图而言可能存在多个这样的结点排序)。该排序满足这样的条件——对于图中的任意两个结点u和v，若存在一条有向边从u指向v,则在拓扑排序u一定出现在v的前面。</p><p>这里引入一个概念——<strong>入度</strong>，即该结点被其他结点连接的数量(是从其他结点指向该节点）。</p><p>而找到入度为0的点，同时把该点连接的其他结点的边删去，同时连接的结点入度减去1，</p><p>再继续找入度点为0的点,重复该循环，直到所有的点都入度为0；<br><strong>注:只有有向非环图才存在拓扑排序</strong></font></p><p><font face="黑体" size=4>解决拓扑排序问题主要分为两个步骤:<br>1.vector存图(还可以用其他方法存图，例如邻接表，邻接矩阵）</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void cuntu(int x,int i)&#123;</span><br><span class="line"> <span class="keyword">in</span>[x]++;//x的入度数加1</span><br><span class="line"> e[i].push_back(x);//x为i的后辈</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="黑体" size=4>2.利用队列bfs找入度为0的结点</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">in</span>[i])&#123;</span><br><span class="line">            q.emplace(i);//先找到入度为0的点塞进队列中</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">while</span>(q.size())&#123;//利用bfs继续寻找入度为0的点</span><br><span class="line">        int t=q.front();</span><br><span class="line">        q.pop();//将入度为0的点删去。</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;e[t].size();i++)&#123;//遍历被删去的点的所有边（指向别的结点）</span><br><span class="line">            int tmp=e[t][i];</span><br><span class="line">            <span class="keyword">in</span>[tmp]--;//删去有向边，同时被指向的结点，入度-1。</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">in</span>[tmp])&#123;//判断是否有删去有向边后有入度为0的点</span><br><span class="line">                q.emplace(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="题目-家谱树"><a href="#题目-家谱树" class="headerlink" title="题目:家谱树"></a>题目:<a href="https://www.luogu.com.cn/problem/B3644">家谱树</a></h2><p><font face="黑体" size=4>有个人的家族很大，辈分关系很混乱，请你帮整理一下这种关系。给出每个人的后代的信息。输出一个序列，使得每个人的后辈都比那个人后列出。</font></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N=105;</span><br><span class="line">int <span class="keyword">in</span>[N],n,x;</span><br><span class="line">vector&lt;int&gt;e[N];</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            <span class="keyword">in</span>[x]++;</span><br><span class="line">            e[i].push_back(x);</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">in</span>[i])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">i&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="string">            q.emplace(i</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">        int t=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;e[t].size();i++)&#123;</span><br><span class="line">            int tmp=e[t][i];</span><br><span class="line">            <span class="keyword">in</span>[tmp]--;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">in</span>[tmp])&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">tmp&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="string">                q.emplace(tmp</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;正楷&quot; size=4&gt;蓝桥杯的时间快到了，我全心学习算法的日子快到头了，其实学习算法还是挺好玩的。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="算法" scheme="http://bighuang.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="有向图中的依赖解析" scheme="http://bighuang.fun/tags/%E6%9C%89%E5%90%91%E5%9B%BE%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>BFS</title>
    <link href="http://bighuang.fun/2023/03/28/BFS/"/>
    <id>http://bighuang.fun/2023/03/28/BFS/</id>
    <published>2023-03-28T12:13:35.000Z</published>
    <updated>2023-03-28T14:01:10.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p><font face="正楷" size=4>前段时间复习了一下<strong>DFS</strong>，认为BFS不必多用，直到我认识到了BFS才具有最短性。</font></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h1><p><font face="正楷" size=4>BFS最让我喜欢的一点是它有固定的模板，也就是套路。<br>先将初始点放进队列中，然后出列遍历每一个点，直到找到最优解，即为最短路。</font><br><strong>模板如下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;int&gt;q;</span><br><span class="line">st[1]=<span class="literal">true</span>;</span><br><span class="line">q.push(1)//从哪个点出发就先将该点放入队列中</span><br><span class="line"><span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">    int t=q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">for</span>(int i=h[t];i!=1;i=ne[i])&#123;//bfs这个点的所有路径</span><br><span class="line">        int j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">            st[j]=<span class="literal">true</span>;</span><br><span class="line">            q.push(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p><strong>和讲解DFS一样都从走迷宫开始</strong></p><h2 id="题目-迷宫"><a href="#题目-迷宫" class="headerlink" title="题目:迷宫"></a>题目:<a href="https://www.luogu.com.cn/problem/P1605">迷宫</a></h2><p><font face="正楷" size=4>这里就不继续写题目了，因为之前已经写过了，不了解的可以点击高亮的“迷宫”直接访问</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;正楷&quot; size=4&gt;前段时间复习了一下&lt;strong&gt;DFS&lt;/strong&gt;，认为BFS不必多用，直到我认识</summary>
      
    
    
    
    <category term="算法" scheme="http://bighuang.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="最短路问题" scheme="http://bighuang.fun/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>hash表</title>
    <link href="http://bighuang.fun/2023/03/26/hash%E8%A1%A8/"/>
    <id>http://bighuang.fun/2023/03/26/hash%E8%A1%A8/</id>
    <published>2023-03-26T09:00:18.000Z</published>
    <updated>2023-03-27T06:36:23.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p><font face="正楷" size=4>在复习hash表的时候遇到了困难，这玩意儿实在是太抽象了。</p><p>我感觉这种与数学沾染了的算法与数据结构，都会变得很抽象。</p><p>这里讲的是自己手写hash表，而不是stl库中的hash表。</p><p>主要是因为有时候引用了stl的undered_map可能会超时，所以下面来模拟一下映射与寻址。</font></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h1><p><font face="正楷" size=4>手写hash表有两种方法，这里讲的是开放寻址法。</font></p><h2 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><p><strong>先定义一个hash数组</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int h[N];//N为数据范围的2倍以上，越大映射得越好。</span><br></pre></td></tr></table></figure><p><strong>接下来便是开放寻址</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int find(int x)&#123;</span><br><span class="line">    int t=x(x%M+M)%M;//映射到<span class="built_in">hash</span>数组上</span><br><span class="line">    <span class="keyword">while</span>(h[t]!=-1&amp;&amp;h[t]!=x)&#123;//寻址的过程</span><br><span class="line">        <span class="keyword">if</span>(++t==m)</span><br><span class="line">            t=0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践:"></a>实践:</h1><p><strong>接下来我们直接上一道蓝桥杯的难题以供大家理解hash表</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p><font face="正楷" size=4>在一个二维平面上放置着 n个炸雷，第 i个炸雷 (xi,yi,ri)表示在坐标 (xi,yi)处存在一个炸雷，它的爆炸范围是以半径为 ri的一个圆。</p><p>为了顺利通过这片土地，需要玩家进行排雷。</p><p>玩家可以发射 m个排雷火箭，小明已经规划好了每个排雷火箭的发射方向，第 j个排雷火箭 (xj,yj,rj)表示这个排雷火箭将会在 (xj,yj)处爆炸，它的爆炸范围是以半径为 rj的一个圆，在其爆炸范围内的炸雷会被引爆。</p><p>同时，当炸雷被引爆时，在其爆炸范围内的炸雷也会被引爆。现在小明想知道他这次共引爆了几颗炸雷？</p><p>你可以把炸雷和排雷火箭都视为平面上的一个点。一个点处可以存在多个炸雷和排雷火箭。当炸雷位于爆炸范围的边界上时也会被引爆。</font></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int N=5e4+5,M=2e5+7,X=1e9+1;</span><br><span class="line">class circle&#123;</span><br><span class="line">public:</span><br><span class="line">    int x,y,r;</span><br><span class="line">&#125;c[N];</span><br><span class="line">int <span class="built_in">id</span>[M];</span><br><span class="line">LL h[M];</span><br><span class="line">bool st[M];</span><br><span class="line">int n,m;</span><br><span class="line">LL get_value(int x,int y)&#123;//将坐标映射成一维数据</span><br><span class="line">    <span class="built_in">return</span> x*X+y;</span><br><span class="line">&#125;</span><br><span class="line">LL find(int x,int y)&#123;</span><br><span class="line">    int value=get_value(x,y);</span><br><span class="line">    int t=(value%M+M)%M;//找到相应<span class="built_in">hash</span>数组下标</span><br><span class="line">    <span class="keyword">while</span>(h[t]!=-1&amp;&amp;h[t]!=value)&#123;//如果该下标有数据同时<span class="built_in">hash</span>数组的val值不等于value往后找</span><br><span class="line">        <span class="keyword">if</span>(++t=M)//当从t搜索到末尾还没有，从头开始搜索</span><br><span class="line">            t=0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">int sqr(int x)&#123;</span><br><span class="line">    <span class="built_in">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x,int y,int r)&#123;</span><br><span class="line">    st[find(x,y)]=<span class="literal">true</span>;//该点的炸雷已经引爆过</span><br><span class="line">    <span class="keyword">for</span>(int xx=x-r;xx&lt;=x+r;xx++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int yy=y-r;yy&lt;=y+r;yy++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sqr(yy-y)+sqr(xx-x)&lt;=sqr(r))&#123;</span><br><span class="line">                int t=find(xx,yy);</span><br><span class="line">                <span class="keyword">if</span>(!st[t]&amp;&amp;<span class="built_in">id</span>[t])&#123;</span><br><span class="line">                    dfs(xx,yy,c[<span class="built_in">id</span>[t]].r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    memset(h,-1,sizeof h);//初始化<span class="built_in">hash</span>数组</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int x,y,r;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;r;</span><br><span class="line">        c[i]=&#123;x,y,r&#125;;</span><br><span class="line">        int t=find(x,y);</span><br><span class="line">        <span class="keyword">while</span>(h[t]==-1)h[t]=get_value(x,y);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">id</span>[t]||c[<span class="built_in">id</span>[t]].r&lt;r)&#123;//该点没有过炸雷，或者之前的炸雷半径比现在的小</span><br><span class="line">            <span class="built_in">id</span>[t]=i;//该坐标有炸雷</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        int x,y,r;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;r;</span><br><span class="line">        <span class="keyword">for</span>(int xx=x-r;xx&lt;=x+r;xx++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int yy=y-r;yy&lt;=y+r;yy++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sqr(xx-x)+sqr(yy-y)&lt;=sqr(r))&#123;//判断是否在圆内</span><br><span class="line">                    int t=find(xx,yy);</span><br><span class="line">                    <span class="keyword">if</span>(!st[t]&amp;&amp;<span class="built_in">id</span>[t])&#123;//该点没有被dfs过，同时该点有炸雷</span><br><span class="line">                        dfs(xx,yy,c[<span class="built_in">id</span>[t]].r);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int res=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;//遍历每个炸雷，统计被引爆的炸雷</span><br><span class="line">        <span class="keyword">if</span>(st[find(c[i].x,c[i].y)])&#123;//若炸雷被引爆,res++;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">res;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;正楷&quot; size=4&gt;在复习hash表的时候遇到了困难，这玩意儿实在是太抽象了。&lt;/p&gt;
&lt;p&gt;我感觉这种与数学</summary>
      
    
    
    
    <category term="数据结构" scheme="http://bighuang.fun/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="hash" scheme="http://bighuang.fun/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>KMP</title>
    <link href="http://bighuang.fun/2023/03/24/KMP/"/>
    <id>http://bighuang.fun/2023/03/24/KMP/</id>
    <published>2023-03-24T12:11:20.000Z</published>
    <updated>2023-03-26T01:47:16.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p><font face="正楷" size=4>昨天不小心玩嗨了，不想更新，坚持了快两个星期的好习惯就这样没了，我对自己真的好失望啊。</p><p>言归正传，今日复习了<strong>KMP</strong>算法，一种解决主串的模式定位问题，比如解决一个主串中是否有另外一个副串。</font></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h1><p><font face="正楷" size=4>kmp算法主要分为两个部分:1.预处理next数组，2.匹配主子串</font></p><h2 id="预处理next数组"><a href="#预处理next数组" class="headerlink" title="预处理next数组"></a>预处理next数组</h2><p><font face="正楷" size=4>kmp与暴力最大的不同在于kmp会根据之前匹配的数据进行处理，以便后面的匹配。</p><p>kmp预处理next数组原理上是记录相同的前后缀，并用next数组记录前缀（遍历的时候指针是在后缀）</p><p>而自己跟自己匹配就是找相同前后缀</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i=2,j=0;i&lt;=lb;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;b[i]!=b[j+1])&#123;</span><br><span class="line">        j=ne[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b[i]==b[j+1])&#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    ne[i]=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配主子串"><a href="#匹配主子串" class="headerlink" title="匹配主子串"></a>匹配主子串</h2><p><font face="正楷" size=4>让主子串进行匹配，如果主串某一位置不匹配子串某一位置，子串从后缀跳到前缀（因为不匹配的前面所以的部分子串与主串相同）</p><p>如果子串走到了子串终点，说明主串中有子串，则子串继续跳到前缀，继续匹配主串，观察是否还有符合子串部分。</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i=1,j=0;i&lt;=la;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;a[i]!=b[j+1])&#123;</span><br><span class="line">        j=ne[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[i]==b[j+1])&#123;</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==lb)&#123;</span><br><span class="line">        j=ne[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="题目：KMP字符串匹配"><a href="#题目：KMP字符串匹配" class="headerlink" title="题目：KMP字符串匹配"></a>题目：<a href="https://www.luogu.com.cn/problem/P3375">KMP字符串匹配</a></h2><p><font face="正楷" size=4>给出两个字符串s1和s2，若s1的区间[l,r]子串与s2完全相同，则s2在s1中出现了，其出现的位置为l。<br>现在请你求出s2在s1中所有出现的位置</font></p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e6+5;</span><br><span class="line">int la,lb,ne[N];</span><br><span class="line">char a[N],b[N];</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    cin&gt;&gt;a+1&gt;&gt;b+1;</span><br><span class="line">    la=strlen(a+1);</span><br><span class="line">    lb=strlen(b+1);</span><br><span class="line">    <span class="keyword">for</span>(int i=2,j=0;i&lt;=lb;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;b[i]!=b[j+1])&#123;</span><br><span class="line">            j=ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b[i]==b[j+1])&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        ne[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=1,j=0;i&lt;=la;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;a[i]!=b[j+1])&#123;</span><br><span class="line">            j=ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==b[j+1])&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==lb)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">i-j+1&lt;&lt;endl;</span></span><br><span class="line"><span class="string">            j=ne[j];</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    for(int i</span>=1;i&lt;=lb;i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">ne[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;正楷&quot; size=4&gt;昨天不小心玩嗨了，不想更新，坚持了快两个星期的好习惯就这样没了，我对自己真的好失望啊。</summary>
      
    
    
    
    <category term="算法" scheme="http://bighuang.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="主串的模式定位问题" scheme="http://bighuang.fun/tags/%E4%B8%BB%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://bighuang.fun/2023/03/22/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://bighuang.fun/2023/03/22/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-22T12:12:04.000Z</published>
    <updated>2023-03-23T02:53:02.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p><font face="正楷" size=4>今日刷题发现蓝桥杯好多dp问题。</p><p>刚好刷到了一道01背包问题，简单地AC后，将全部的背包问题复习了一下</p><p>接下来让我浅浅地分享一下背包问题家族</font></p><h1 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h1><p><font face="正楷" size=4>背包问题一共有三大类:01背包、完全背包、多重背包。</p><h2 id="01背包："><a href="#01背包：" class="headerlink" title="01背包："></a>01背包：</h2><p>01背包问题是比较简单的，简单来说就是每种物品只能选一次，在有限的体积下选取价值最大的。之所以称之为01背包问题，是因为在只有二进制的计算机中0常常表示否，也就是拒绝，1恰巧相反。<br>01背包常见的模板如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(int j=m;j&gt;=v[i];j--)&#123;</span><br><span class="line">        dp[j]=max(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包:"></a>完全背包:</h2><p>完全背包与01背包的不同在于完全背包的每种物品有无数件，只要空间足够可以无限取。<br>完全背包常见的模板如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(int j=v[i];j&lt;=v;j++)&#123;</span><br><span class="line">        dp[j]=max(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重背包："><a href="#多重背包：" class="headerlink" title="多重背包："></a>多重背包：</h2><p>多重背包在01背包上加了特殊条件，每种物品都有特定的件数，所以可以将多重背包转化为01背包<br>多重背包常见的模板如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    int t=1;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=t)&#123;</span><br><span class="line">        xb++;</span><br><span class="line">        v[xb]=t*vi,w[xb]=wi*t;</span><br><span class="line">        t*=2;</span><br><span class="line">        s-=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(s)&#123;</span><br><span class="line">        xb++;</span><br><span class="line">        v[xb]=s*vi,w[xb]=s*wi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=xb;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(int j=V;j&gt;=v[i];j--)&#123;</span><br><span class="line">        dp[j]=max(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单地介绍一下，接下来让我们实践一下。</font></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="01背包：01背包"><a href="#01背包：01背包" class="headerlink" title="01背包：01背包"></a>01背包：<a href="https://www.luogu.com.cn/problem/T243580">01背包</a></h2><p><font face="正楷" size=4>有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的空间是 C i ，得到的价值是 W i 。求解在不超过容量的前提下，将哪些物品装入背包可使价值总和最大。</font></p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N=105;</span><br><span class="line">int dp[N];</span><br><span class="line">int n,V;</span><br><span class="line">int w[N],v[N];</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;V;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=V;j&gt;=v[i];j--) &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">dp[V];</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="完全背包：完全背包"><a href="#完全背包：完全背包" class="headerlink" title="完全背包：完全背包"></a>完全背包：<a href="https://www.luogu.com.cn/problem/T164644">完全背包</a></h2><p><font face="正楷" size=4>设有n种物品，每种物品有一个重量及一个价值。但每种物品的数量是无限的，同时有一个背包，最大载重量为M，今从n种物品中选取若干件(同一种物品可以多次选取)，使其重量的和小于等于M，而价值的和为最大。</font></p><h3 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N=35;</span><br><span class="line">int n,V;</span><br><span class="line">int v[N],w[N],dp[N];</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    cin&gt;&gt;V&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=v[i];j&lt;=V;j++)&#123;</span><br><span class="line">            dp[j]=max(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">dp[V];</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="多重背包：多重背包"><a href="#多重背包：多重背包" class="headerlink" title="多重背包：多重背包"></a>多重背包：<a href="https://www.luogu.com.cn/problem/U280382">多重背包</a></h2><p><font face="正楷" size=4>有 N 种物品和一个容量是 V 的背包。</p><p>第 i 种物品最多有 si 件，每件体积是 vi ，价值是 wi 。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。 输出最大价值。</font></p><h3 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N=105;</span><br><span class="line">int v[N],w[N],dp[N];</span><br><span class="line">int vi,wi;</span><br><span class="line">int n,V,xb,s;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;V;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;vi&gt;&gt;wi&gt;&gt;s;</span><br><span class="line">        int t=1;</span><br><span class="line">        <span class="keyword">while</span>(s&gt;=t)&#123;</span><br><span class="line">            xb++;</span><br><span class="line">            w[xb]=wi*t,v[xb]=vi*t;</span><br><span class="line">            s-=t;</span><br><span class="line">            t&lt;&lt;<span class="string">1;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        if(s)&#123;</span></span><br><span class="line"><span class="string">            xb++;</span></span><br><span class="line"><span class="string">            w[xb]=wi*s,v[xb]=vi*s;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    for(int i=1</span>;i&lt;=xb;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=V;j&gt;=v[i];j--)&#123;</span><br><span class="line">            dp[j]=max(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">dp[V];</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;正楷&quot; size=4&gt;今日刷题发现蓝桥杯好多dp问题。&lt;/p&gt;
&lt;p&gt;刚好刷到了一道01背包问题，简单地AC</summary>
      
    
    
    
    <category term="算法" scheme="http://bighuang.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="背包问题" scheme="http://bighuang.fun/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://bighuang.fun/2023/03/21/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://bighuang.fun/2023/03/21/%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2023-03-21T04:13:50.000Z</published>
    <updated>2023-03-21T13:05:37.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p><font face="正楷" size=4>这段时间刚复习完dfs，然后在洛谷上用模板暴力解决了一道N皇后问题。</p><p>而当我想继续将N皇后问题一网打尽时，有一道N皇后问题直接让我TLE，让我这个蒟蒻不能AC这道题目。</p><p>而这道题恰好克制了朴素的dfs，也就是需要优化dfs。本蒟蒻花了好长时间看了代码终于弄懂了，也就是运用位运算优化了dfs</p><p>接下来让我来分享一下位运算这个常用的小算法。</font></p><h1 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h1><p><font face="正楷" size=4>下面介绍两个常用的位运算的函数（其实也不能称之为函数），都是针对为了表示二进制的数</font></p><h2 id="求n的第k为数字："><a href="#求n的第k为数字：" class="headerlink" title="求n的第k为数字："></a>求n的第k为数字：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n&gt;&gt;k&amp;1;</span><br></pre></td></tr></table></figure><h2 id="返回n的第一位1二进制数"><a href="#返回n的第一位1二进制数" class="headerlink" title="返回n的第一位1二进制数:"></a>返回n的第一位1二进制数:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int lowbit(x)&#123;</span><br><span class="line">    <span class="built_in">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="正楷" size=4>OK简单地介绍了一下位运算，接下来用实战来领悟得更透彻一些</font></p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="题目：还是N皇后"><a href="#题目：还是N皇后" class="headerlink" title="题目：还是N皇后"></a>题目：<a href="https://www.luogu.com.cn/problem/P1562">还是N皇后</a></h2><p><font face="正楷" size=4>正如题目所说，这题是著名的N皇后问题。第一行有一个N。接下来有N行N列描述一个棋盘，“*”表示可放“.”表示不可放。输出方案数</font></p><h3 id="位运算代码实现："><a href="#位运算代码实现：" class="headerlink" title="位运算代码实现："></a>位运算代码实现：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define lowbit(x) ((x)&amp;(-x))//定义一个宏实现lowbit</span></span><br><span class="line">const int N=50;</span><br><span class="line">char g[N][N];</span><br><span class="line">int n,dg,udg,col;//dg,udg,col表示当前这一行N皇后放置位置的情况</span><br><span class="line">int res,dep;//res记录方案数,dep表示当前是第几行</span><br><span class="line">int f[N];//记录每一行初始状态下放置N皇后的情况</span><br><span class="line">void dfs(int col,int dg,int udg,int dep)&#123;</span><br><span class="line">    <span class="keyword">if</span>(col==(1&lt;&lt;<span class="string">n)-1)&#123;</span></span><br><span class="line"><span class="string">        res++;</span></span><br><span class="line"><span class="string">        return ;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    int s=((1&lt;&lt;n</span>)-1)&amp;~(col|dg|udg|f[dep]);//将改行可放置N皇后的地方&amp;出来，</span><br><span class="line">            // col|dg|udg|f[dep]将每一个不可放置的地方叠加起来，取反后&amp;上((<span class="number">1</span>&lt;&lt;n)-<span class="number">1</span>)</span><br><span class="line">     while(s)&#123;</span><br><span class="line">         int w=lowbit(s);//先从最低位可放置N皇后的情况开始枚举</span><br><span class="line">         dfs(col|w,(dg|w)&lt;&lt;<span class="number">1</span>,(udg|w)&gt;&gt;<span class="number">1</span>,dep+<span class="number">1</span>);//col|w表示正下方无法放置N皇后</span><br><span class="line">         //(dg|w)&lt;&lt;<span class="number">1</span>表示正左下方不能放置，(udg|w)&gt;&gt;<span class="number">1</span>表示正右下方不能放置;</span><br><span class="line">         s-=w;//继续在这一行进行搜索是否有放置N皇后</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            if(cin&gt;&gt;g[i][j],g[i][j]==&#x27;.&#x27;)&#123;</span><br><span class="line">                f[i]|=<span class="number">1</span>&lt;&lt;n-j;//初始化每一行N皇后初始可放置的条件</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;正楷&quot; size=4&gt;这段时间刚复习完dfs，然后在洛谷上用模板暴力解决了一道N皇后问题。&lt;/p&gt;
&lt;p&gt;而当我</summary>
      
    
    
    
    <category term="算法" scheme="http://bighuang.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="位运算" scheme="http://bighuang.fun/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://bighuang.fun/2023/03/20/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://bighuang.fun/2023/03/20/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2023-03-20T12:21:57.000Z</published>
    <updated>2023-03-26T08:59:28.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p><font face="正楷" size=4>今日浅浅地玩了一下刺客信条奥赛德，总结还不错。不闹了，让我来介绍一下今天的主角<strong>并查集</strong></font></p><p>$ 概述:<br><font face="正楷" size=4>并查集还是很神奇的，常常地用在处理两个集合问题，例如两集合的关系。</p><p>并查集有三大核心步骤–<strong>初始化</strong>、<strong>寻找根部</strong>、<strong>合并</strong>，可以当成解题模板使用</p><p>初始化即先将每一个元素的祖宗设为自己。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i;i&lt;=n;i++)</span><br><span class="line">f[i]=i;</span><br></pre></td></tr></table></figure><p>寻找根部，找到该元素的祖宗。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int find(int x)</span><br><span class="line"><span class="keyword">if</span>(f[x]==x)<span class="built_in">return</span> x ;</span><br><span class="line"><span class="built_in">return</span> f[x]=find(f[x]);//这一步为路径压缩，使得每一个元素都指向该集合的祖宗。</span><br></pre></td></tr></table></figure><p>合并就是将两个元素或者两个集合进行合并，将一方的根节点连接到另一方的根节点，进行认祖归宗。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[find(a)]=find(b);</span><br></pre></td></tr></table></figure><p>简单地介绍了一下并查集，现在我们开始实战环节。</font></p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="题目：并查集"><a href="#题目：并查集" class="headerlink" title="题目：并查集"></a>题目：<a href="https://www.luogu.com.cn/problem/P3367">并查集</a></h2><p><font face="正楷" size=4>如题，现在有一个并查集，你需要完成合并和查询操作。</p><p>第一行包含两个整数 <code>N,M</code> ,表示共有 <code>N</code> 个元素和 <code>M</code> 个操作。</p><p>接下来 <code>M</code> 行，每行包含三个整数 <code>Z_i,X_i,Y_i</code> 。</p><p>当 <code>Z_i=1</code> 时，将 <code>X_i</code> 与 <code>Y_i</code> 所在的集合合并。</p><p>当 <code>Z_i=2</code> 时，输出 <code>X_i</code> 与 <code>Y_i</code> 是否在同一集合内，是的输出 <code>Y</code> ；否则输出 <code>N</code> 。</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N=100010;</span><br><span class="line">int p[N],n,m;</span><br><span class="line">void <span class="function"><span class="title">init</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">int myFind(int x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x)p[x]=myFind(p[x]);</span><br><span class="line">    <span class="built_in">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line">void myMerge(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    p[myFind(a)]=myFind(b);</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    int a,b;</span><br><span class="line">    int number ;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;number&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(number==1)</span><br><span class="line">            myMerge(a,b);</span><br><span class="line">        <span class="keyword">if</span>(number==2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(myFind(a)==myFind(b))</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Y&quot;</span>&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            else</span></span><br><span class="line"><span class="string">                cout&lt;&lt;&quot;N&quot;&lt;&lt;endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;正楷&quot; size=4&gt;今日浅浅地玩了一下刺客信条奥赛德，总结还不错。不闹了，让我来介绍一下今天的主角&lt;stron</summary>
      
    
    
    
    <category term="数据结构" scheme="http://bighuang.fun/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="最短路问题" scheme="http://bighuang.fun/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>深度优先搜索</title>
    <link href="http://bighuang.fun/2023/03/19/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <id>http://bighuang.fun/2023/03/19/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</id>
    <published>2023-03-19T08:05:51.000Z</published>
    <updated>2023-03-19T23:48:17.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p><font face="正楷" size=3>今日打只狼打得吐血了，直接把它给卸载了，然后狠狠地复习了一下<strong>深度优先的算法</strong>、</p><p>so现在让我来分享一下深度优先搜索也就是<strong>dfs</strong></font></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h1><p><font face="正楷" size=4>深度优先搜索可以理解为一个栈，一直遍历一条路径，直至终点才将这个栈释放，再用栈存储其他路径。</p><p>同时该算法和bfs（广度优先搜索）一样只能用于权重一样的题目中，而出现只有大小不一的正权边优先使用Dijksra，含有负权边使用bell ford。</p><p>当dfs到达一条终点后它便会回溯，找其他的路径，不断地比较，找到最优解。但值得注意的是深度优先搜素不具有最短性</p><p>只有广度优先搜索才具有最短性（即访问最近的点才能具有最短性）。现在让我用例题了解一下深度优先搜索的搜索方式以及回溯过程</font></p><p>#实践:</p><h2 id="题目：迷宫"><a href="#题目：迷宫" class="headerlink" title="题目：迷宫"></a>题目：<a href="https://www.luogu.com.cn/problem/P1605">迷宫</a></h2><p><font face="正楷" size=4>给定一个 N×M 方格的迷宫，迷宫里有 T 处障碍，障碍处不可通过。</p><p>在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。</p><p>给定起点坐标和终点坐标，每个方格最多经过一次，问有多少种从起点坐标到终点坐标的方案。</font></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;//懒人万能头</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e4,M=1e4;</span><br><span class="line">int g[N][M];</span><br><span class="line">int bx,by,fx,fy;</span><br><span class="line">bool st[N][M];//用来记录一条路径中该点是否走过</span><br><span class="line">int n,m,t;</span><br><span class="line">int dx[4]=&#123;1,0,-1,0&#125;,dy[4]=&#123;0,1,0,-1,&#125;;//表示一点上下左右四个方向移动，避免四个循环重复，增加代码可读性</span><br><span class="line">int cnt;//记录多少中情况</span><br><span class="line">void dfs(int bx,int by)&#123;</span><br><span class="line">    <span class="keyword">if</span>(bx==fx&amp;&amp;by==fy)&#123;</span><br><span class="line">        cnt++;//当有一条路径走到终点，种类数加1</span><br><span class="line">        <span class="built_in">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int k=0;k&lt;=3;k++)&#123;</span><br><span class="line">        int tx=bx+dx[k],ty=by+dy[k];</span><br><span class="line">        <span class="keyword">if</span>(!st[bx+dx[k]][by+dy[k]]&amp;&amp;g[tx][ty]==1)&#123;</span><br><span class="line">            st[bx][by]=<span class="literal">true</span>;</span><br><span class="line">            dfs(tx,ty);</span><br><span class="line">            st[bx][by]=<span class="literal">false</span>;//这便是回溯</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;</span><br><span class="line">    cin&gt;&gt;bx&gt;&gt;by&gt;&gt;fx&gt;&gt;fy;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">            g[i][j]=1;//绘图</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        int x, y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        g[x][y]=0;//设置障碍</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(bx,by);</span><br><span class="line">    cout&lt;&lt;<span class="string">cnt;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;正楷&quot; size=3&gt;今日打只狼打得吐血了，直接把它给卸载了，然后狠狠地复习了一下&lt;strong&gt;深度优先的算法</summary>
      
    
    
    
    <category term="算法" scheme="http://bighuang.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="最短路问题" scheme="http://bighuang.fun/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra处理最短路问题</title>
    <link href="http://bighuang.fun/2023/03/18/Dijkstra%E5%A4%84%E7%90%86%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    <id>http://bighuang.fun/2023/03/18/Dijkstra%E5%A4%84%E7%90%86%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-18T13:40:00.000Z</published>
    <updated>2023-03-20T13:37:30.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p><font face="正楷" size=4>今日温习了前段时间学习的<strong>Dijkstra算法</strong>我在复习这个算法的时候，常常因为没有初始化或者条件判断而错误。</p><p>现在让我来浅谈一下我对该算法的理解</font></p><h1 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h1><p><font face="正楷" size=4>该算法常常应用在处理单源最短路问题，具体的数学证明以及原理可以查百度。</p><p>大致是通过不断迭代找到当前最短路径，再通过该最短路径往后延伸，找到到终点的最短路径。</p><p>常见的Dijkstra算法分为朴素版以及堆优化版，前者的时间复杂度为O(N*N),后者的时间复杂度为O(MlogN)，其中N为点的个数，M为边的个数</p><p>朴素版用来处理稠密图，稠密图用邻接矩阵存储图，堆优化版用来处理稀疏图，稀疏图用邻接表存储图。</font></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="题目-租用游艇"><a href="#题目-租用游艇" class="headerlink" title="题目:租用游艇"></a>题目:<a href="https://www.luogu.com.cn/problem/P1359">租用游艇</a></h2><p><font face="正楷" size=4>长江游艇俱乐部在长江上设置了 n 个游艇出租站 1,2,……,n。游客可在这些游艇出租站租用游艇，并</p><p>在下游的任何一个游艇出租站归还游艇。游艇出租站i到游艇出租站j之间的租金为 r(i,j)（1&lt;=i&lt;=j）。</p><p>试设计一个算法，计算出从游艇出租站1到游艇出租站n所需的最少租金。</font></p><h3 id="解法一：朴素版Dijkstra"><a href="#解法一：朴素版Dijkstra" class="headerlink" title="解法一：朴素版Dijkstra"></a>解法一：朴素版Dijkstra</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N=10010;</span><br><span class="line">int g[N][N],dist[N];//g[N][N]表示相邻两点的距离，dist[N]表示从起点到某一点的最短路径</span><br><span class="line">bool st[N];//st[N]表示该点是否被利用找过最短路径</span><br><span class="line">int n;</span><br><span class="line">int <span class="function"><span class="title">dijkstra</span></span>()&#123;</span><br><span class="line">    memset(dist,0x3f,sizeof dist);//初始化数组</span><br><span class="line">    dist[1]=0;//特殊情况特殊考虑</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;=n-1;i++)&#123;//进行n-1次迭代找到最小路径</span><br><span class="line">        int t=-1;//为每一次迭代的初始点提供便利</span><br><span class="line">        <span class="keyword">for</span>(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==-1||dist[t]&gt;dist[j]))&#123;</span><br><span class="line">                t=j;//该点既要没被利用过同时也是目前的最短路径</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            dist[j]=min(dist[j],dist[t]+g[t][j]);//利用更新的点找最短路径</span><br><span class="line">        &#125;</span><br><span class="line">        st[t]=<span class="literal">true</span>;//标记该点已被利用过</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    memset(g,0x3f,sizeof g);</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt; <span class="string">dijkstra();</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="解法二-堆优化版Dijkstra"><a href="#解法二-堆优化版Dijkstra" class="headerlink" title="解法二: 堆优化版Dijkstra"></a>解法二: 堆优化版Dijkstra</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">const int N=1005;</span><br><span class="line">bool st[N];</span><br><span class="line">int a[N][N];</span><br><span class="line">int w[N],h[N],ne[N],e[N],idx;//构建邻接表</span><br><span class="line">int n,dist[N];</span><br><span class="line">void add(int x,int y,int c)&#123;//连接边</span><br><span class="line">    w[idx]=c;</span><br><span class="line">    e[idx]=y;</span><br><span class="line">    ne[idx]=h[x];</span><br><span class="line">    h[x]=idx++;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">dijkstra</span></span>()&#123;</span><br><span class="line">    memset(dist,0x3f,sizeof dist);</span><br><span class="line">    dist[1]=0;</span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;heap;//建立小顶堆，优先对第一个元素从小到大排序，其次才是第二个元素</span><br><span class="line">    heap.emplace(0,1);</span><br><span class="line">    <span class="keyword">while</span>(heap.size())&#123;</span><br><span class="line">        auto t=heap.top();//不断利用该当前最小路径点，找到最终最小路径</span><br><span class="line">        heap.pop();//利用过后排出</span><br><span class="line">        int ver=t.second,val=t.first;</span><br><span class="line">        <span class="keyword">if</span>(st[ver])<span class="built_in">continue</span>;</span><br><span class="line">        st[ver]=<span class="literal">true</span>;//将利用过的点打上标记</span><br><span class="line">        <span class="keyword">for</span>(int i=h[ver];i!=-1;i=ne[i])&#123;//利用该点更新最短路径</span><br><span class="line">            int j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;val+w[i])&#123;</span><br><span class="line">                dist[j]=val+w[i];</span><br><span class="line">                heap.emplace(dist[j],j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    memset(a,0x3f,sizeof a);</span><br><span class="line">    memset(h,-1,sizeof h);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">            add(i,j,a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">dijkstra();</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;正楷&quot; size=4&gt;今日温习了前段时间学习的&lt;strong&gt;Dijkstra算法&lt;/strong&gt;我在复习这个</summary>
      
    
    
    
    <category term="算法" scheme="http://bighuang.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="最短路问题" scheme="http://bighuang.fun/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>状压dp</title>
    <link href="http://bighuang.fun/2023/03/17/%E7%8A%B6%E5%8E%8Bdp/"/>
    <id>http://bighuang.fun/2023/03/17/%E7%8A%B6%E5%8E%8Bdp/</id>
    <published>2023-03-17T00:59:55.000Z</published>
    <updated>2023-03-27T06:48:49.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p><font face="正楷" size=3>昨日学习状态压缩dp学的我快疯掉了，第一次接触<strong>状压dp</strong>雀氏第一时间很难接受。</p><p>so写一篇博客加以总结</font></p><h1 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h1><p><font face="正楷" size=4>状态压缩不同于线性dp区间dp等，经常用二进制数表示某一种状态。</p><p>下面就让两道题带你了解状压dp的魅力。</font></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践:"></a>实践:</h1><h2 id="题目一：蒙德里安的梦想"><a href="#题目一：蒙德里安的梦想" class="headerlink" title="题目一：蒙德里安的梦想"></a>题目一：<a href="https://www.acwing.com/problem/content/description/293/">蒙德里安的梦想</a></h2><p><font face="正楷" size=4>求把 N<em>M的棋盘分割成若干1</em>2的长方形，有多少种方案</font></p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N=12,M=1&lt;&lt;<span class="string">N;</span></span><br><span class="line"><span class="string">long long dp[N</span>][M];//建立动态规划数组</span><br><span class="line">bool st[M];</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m,n|m)&#123;//读入数据</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;1&lt;&lt;<span class="string">n;i++)&#123;</span></span><br><span class="line"><span class="string">            st[i]=true;//先初始化该二进制是否合法，即是否符合摆放条件</span></span><br><span class="line"><span class="string">            int cnt=0;//统计该数字有几个0</span></span><br><span class="line"><span class="string">            for(int j=0;j&lt;n</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;&gt;j&amp;1)&#123;//不断右移数字，计数0个数</span><br><span class="line">                    <span class="keyword">if</span>(cnt&amp;1)&#123;//若有奇数个0不符合摆放条件</span><br><span class="line">                        st[i]=<span class="literal">false</span>;</span><br><span class="line">                        <span class="built_in">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt&amp;1)st[i]=<span class="literal">false</span>;//特殊处理高位0的情况</span><br><span class="line">        &#125;</span><br><span class="line">        memset(dp,0,sizeof dp);//初始化数组</span><br><span class="line">        dp[0][0]=1;//考虑特殊情况</span><br><span class="line">        <span class="keyword">for</span>(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j=0;j&lt;1&lt;&lt;<span class="string">n;j++)&#123;</span></span><br><span class="line"><span class="string">                for(int k=0;k&lt;1&lt;&lt;n</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(st[j|k]&amp;&amp;(j&amp;k)==0)&#123;//只判断前一列和后一列摆放合法，同时前后不能有重叠部分</span><br><span class="line">                        dp[i][j]+=dp[i-1][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">dp[m][0]&lt;&lt;endl;//最后一列只能竖放，同时二进制数肯定为0000，则最终答案为dp</span>[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目二-最短hamilton路径"><a href="#题目二-最短hamilton路径" class="headerlink" title="题目二:最短hamilton路径"></a>题目二:<a href="https://www.acwing.com/problem/content/description/93/">最短hamilton路径</a></h2><p><font face="正楷" size=4>给定一个n个点的带权无向图，点从0~n-1标号，求起点为0到终点n-1的最短Hamilton路径</p><p>Hamilton路径的定义是从0到n-不重不漏地经过每一个点恰好为1</font></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N=21,M=1&lt;&lt;<span class="string">N;</span></span><br><span class="line"><span class="string">int w[N</span>][N],dp[M][N];//M表示二进制数。N表示当前为什么点</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;S</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(dp,0x3f,sizeof dp);</span><br><span class="line">    dp[1][0]=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;1&lt;&lt;<span class="string">n;i++)&#123;</span></span><br><span class="line"><span class="string">        if(i&amp;1)&#123;//因为题目要求从0这个点开始走，所以二进制最后一个数一定为1</span></span><br><span class="line"><span class="string">            for (int j = 0; j &lt; n</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;&gt; j &amp; 1) &#123;//保证i的二进制数中为数字为1时起跳，这样才合法</span><br><span class="line">                    <span class="keyword">for</span> (int k = 0; k &lt; n; k++) &#123;//枚举跳到j之前的k点</span><br><span class="line">                        <span class="keyword">if</span> ((i - (<span class="number">1</span> &lt;&lt; j)) &gt;&gt; k &amp; 1) &#123;</span><br><span class="line">                            dp[i][j] = min(dp[i][j], dp[i - (1 &lt;&lt; <span class="string">j)][k] + w[k][j</span>]);</span><br><span class="line">                        &#125;//去掉j这个点，同时找到合法的起跳点k</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">dp[(1&lt;&lt;n)-1][n-1];//最终答案肯定在二进制数全为1的点，且最终点为n-1；</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;正楷&quot; size=3&gt;昨日学习状态压缩dp学的我快疯掉了，第一次接触&lt;strong&gt;状压dp&lt;/strong</summary>
      
    
    
    
    <category term="算法" scheme="http://bighuang.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="http://bighuang.fun/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>差分</title>
    <link href="http://bighuang.fun/2023/03/16/%E5%B7%AE%E5%88%86/"/>
    <id>http://bighuang.fun/2023/03/16/%E5%B7%AE%E5%88%86/</id>
    <published>2023-03-16T07:25:58.000Z</published>
    <updated>2023-03-16T08:38:46.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p><font face="正楷" size=4>好几个星期前学的，逐渐淡忘了，今日再次遇见，专门写一篇博客介绍很好用的一个算法–<strong>差分</strong></font></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h1><p><font face="正楷" size=4>差分算法适用于区间加减一个数，是前缀和的逆运算，二者经常出现在同一题目。</p><p>同时差分和前缀和一样分为一维差分与二维差分，下面将用题目带大家了解差分</font></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践:"></a>实践:</h1><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><p><strong>一维差分核心公式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[l]+=w;//注意是对差分数组进行操作</span><br><span class="line">a[r+1]-=w;</span><br></pre></td></tr></table></figure><h3 id="题目-小明的彩灯"><a href="#题目-小明的彩灯" class="headerlink" title="题目:小明的彩灯"></a>题目:<a href="https://www.lanqiao.cn/problems/1276/learning/">小明的彩灯</a></h3><p><font face="正楷" size=4>小明拥有N个彩灯，第i个彩灯的初始亮度为ai。</p><p>小明将进行Q次操作，每次操作可选择一段区间，并使区间内彩灯的亮度+x（x可能为负数）。</p><p>求Q次操作后每一个彩灯的亮度（若彩灯亮度为负数则输出为0）</font></p><h4 id="代码实现-差分-前缀和"><a href="#代码实现-差分-前缀和" class="headerlink" title="代码实现: 差分+前缀和"></a>代码实现: 差分+前缀和</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e5;</span><br><span class="line">int s[N],a[N];</span><br><span class="line">void insert(int l,int r,int w)//进行差分，使得区间加减w</span><br><span class="line">&#123;</span><br><span class="line">    a[l]+=w;</span><br><span class="line">    a[r+1]-=w;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    int n,q;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)cin &gt;&gt;s[i];</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)insert(i,i,s[i]);//获得差分数组</span><br><span class="line">    <span class="keyword">while</span>(q--)//进行操作</span><br><span class="line">    &#123;</span><br><span class="line">        int l,r,w;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;w;</span><br><span class="line">        insert(l,r,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)//进行前缀和</span><br><span class="line">        a[i]+=a[i-1];</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=0)cout&lt;&lt;<span class="string">0&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="string">        else cout&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><p><strong>二维差分核心公式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b[x1][y1]+=1;</span><br><span class="line">b[x2+1][y1]-=1;</span><br><span class="line">b[x1][y2+1]-=1;</span><br><span class="line">b[x2+1][y2+1]+=1;</span><br></pre></td></tr></table></figure><h3 id="题目-地毯"><a href="#题目-地毯" class="headerlink" title="题目:地毯"></a>题目:<a href="https://www.luogu.com.cn/problem/P3397">地毯</a></h3><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1005,M=1005;</span><br><span class="line">int b[N][N];</span><br><span class="line">void insert(int x1,int y1,int x2,int y2)</span><br><span class="line">&#123;</span><br><span class="line">    b[x1][y1]+=1;</span><br><span class="line">    b[x2+1][y1]-=1;</span><br><span class="line">    b[x1][y2+1]-=1;</span><br><span class="line">    b[x2+1][y2+1]+=1;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        int x1,y1,x2,y2;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        insert(x1,y1,x2,y2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(int j=1;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = 1; j &lt;= n; j++)</span><br><span class="line">            cout &lt;&lt; <span class="string">b[i][j] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"><span class="string">        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;正楷&quot; size=4&gt;好几个星期前学的，逐渐淡忘了，今日再次遇见，专门写一篇博客介绍很好用的一个算法–&lt;st</summary>
      
    
    
    
    <category term="算法" scheme="http://bighuang.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="基础算法" scheme="http://bighuang.fun/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>区间dp</title>
    <link href="http://bighuang.fun/2023/03/15/%E5%8C%BA%E9%97%B4dp/"/>
    <id>http://bighuang.fun/2023/03/15/%E5%8C%BA%E9%97%B4dp/</id>
    <published>2023-03-15T08:12:37.000Z</published>
    <updated>2023-03-16T07:54:00.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p><font face="正楷" size=3>今日之所学<strong>区间dp</strong>，归一总结</font></p><h1 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h1><p><font face="正楷" size=3>所谓区间dp，指在一段区间上进行动态规划，一般做法是由长度较小的区间往长度较大的区间进行递推，最终得到整个区间的答案，而边界就是长度为1以及2的区间。</font><br><font face="正楷" size=3>区间dp常见的转移方程如下：</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp(i,j) = min&#123;dp(i,k-1) + dp(k,j)&#125; + w(i,j)   (i &lt; k &lt;= j)</span><br></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="题目：石子合并"><a href="#题目：石子合并" class="headerlink" title="题目：石子合并"></a>题目：<a href="https://www.luogu.com.cn/problem/P1880">石子合并</a></h2><p><font face="正楷" size=4> 在一个操场摆放 N堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 2 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。试设计出一个算法,计算出将 N堆石子合并成 1堆的最小得分</font></p><h3 id="解法："><a href="#解法：" class="headerlink" title="解法："></a><strong>解法：</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N=105;</span><br><span class="line">int dp[N][N],s[N];</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;cin&gt;&gt;s[i];s[i]+=s[i-1];&#125;</span><br><span class="line">    <span class="keyword">for</span>(int len=2;len&lt;=n;len++)</span><br><span class="line">        <span class="keyword">for</span>(int i=1;len+i-1&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int l=i;</span><br><span class="line">            int r=len+l-1;</span><br><span class="line">            dp[l][r]=1e6;</span><br><span class="line">            <span class="keyword">for</span>(int k=l;k&lt;r;k++)</span><br><span class="line">                dp[l][r]=min(dp[l][r],dp[l][k]+dp[k+1][r]+s[r]-s[l-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">dp[1][n];</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;正楷&quot; size=3&gt;今日之所学&lt;strong&gt;区间dp&lt;/strong&gt;，归一总结&lt;/font&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="算法" scheme="http://bighuang.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="http://bighuang.fun/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>线性dp</title>
    <link href="http://bighuang.fun/2023/03/14/%E7%BA%BF%E6%80%A7dp/"/>
    <id>http://bighuang.fun/2023/03/14/%E7%BA%BF%E6%80%A7dp/</id>
    <published>2023-03-14T12:50:29.000Z</published>
    <updated>2023-03-16T07:54:45.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p><font face="正楷" size=3>今日所学知识点–<strong>线性dp</strong></font><br><font face="正楷" size=3>在此进行归纳和总结，以及分享题解</font></p><h1 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h1><p><font face="正楷" size=4>线性动态规划，是较常见的一类动态规划问题，其是在线性结构上进行状态转移，这类问题不像背包问题、区间DP等有固定的模板。</font></p><p><font face="正楷" size=4>线性动态规划的目标函数为特定变量的线性函数，约束是这些变量的线性不等式或等式，目的是求目标函数的最大值或最小值。</font></p><p><font face="正楷" size=4>因此，除了少量问题有固定的模板外，大部分都要根据实际问题来推导得出答案。</font></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="题目一：数学三角形"><a href="#题目一：数学三角形" class="headerlink" title="题目一：数学三角形"></a>题目一：<a href="https://www.lanqiao.cn/problems/505/learning/?first_category_id=1&sort=students_count&second_category_id=3&name=%E4%B8%89%E8%A7%92%E5%BD%A2">数学三角形</a></h2><p><font face="正楷" size=4>给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右 边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过 1。</font></p><h3 id="解法：自顶向下dp"><a href="#解法：自顶向下dp" class="headerlink" title="解法：自顶向下dp"></a><strong>解法：自顶向下dp</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e3+10;</span><br><span class="line">int dp[N][N],w[N][N];</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(int j=1;j&lt;=i;j++)</span><br><span class="line">            cin&gt;&gt;w[i][j];</span><br><span class="line">    dp[1][1]=w[1][1];</span><br><span class="line">    <span class="keyword">for</span>(int i=2;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(int j=1;j&lt;i;j++)</span><br><span class="line">            dp[i][j]=max(dp[i-1][j],dp[i-1][j-1])+w[i][j];</span><br><span class="line">    cout&lt;&lt;<span class="string">max(dp[n][(n+1)/2],dp[n][(n+2)/2]);</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="题目二：最长上升子序列"><a href="#题目二：最长上升子序列" class="headerlink" title="题目二：最长上升子序列"></a>题目二：<a href="https://www.luogu.com.cn/problem/B3637">最长上升子序列</a></h2><p><font face="正楷" size=4>这是一个简单的动规板子题。<br>给出一个由n(n&lt;=5000)个不超过1e6的正整数组成的序列。请输出这个序列<strong>最长上升子序列</strong>的长度。</p><p>最长上升子序列是指，从原序列中按顺序取出一些数字排在一起，这些数字是逐渐增大的。</font></p><h3 id="解法：动态规划"><a href="#解法：动态规划" class="headerlink" title="解法：动态规划"></a><strong>解法：动态规划</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace  std;</span><br><span class="line">const int N=1e6;</span><br><span class="line">int q[N];</span><br><span class="line">int dp[N];</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    int n,res=0;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;q[i];</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i]=1;</span><br><span class="line">        <span class="keyword">for</span>(int j=1;j&lt;i;j++)</span><br><span class="line">            <span class="keyword">if</span>(q[i]&gt;q[j])</span><br><span class="line">                dp[i]=max(dp[j]+1,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">            res=max(res,dp[i]);</span><br><span class="line">        cout&lt;&lt;<span class="string">res&lt;&lt;endl;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h2 id="题目三-最长公共子序列"><a href="#题目三-最长公共子序列" class="headerlink" title="题目三:最长公共子序列"></a>题目三:<a href="https://www.luogu.com.cn/problem/P1439">最长公共子序列</a></h2><p><font face="正楷" size=4>给出两个字符串s1，s2，求出它们最长公共长度子序列的长度</font></p><h3 id="解法：动态规划-1"><a href="#解法：动态规划-1" class="headerlink" title="解法：动态规划"></a><strong>解法：动态规划</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e3+5;</span><br><span class="line">char a[N],b[N];</span><br><span class="line">int dp[N][N];</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    cin&gt;&gt;a+1&gt;&gt;b+1;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(int j=1;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=max(dp[i-1][j],dp[i][j-1]);</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j])dp[i][j]=dp[i-1][j-1]+1;</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">endl;</span></span><br><span class="line"><span class="string">    cout&lt;&lt;dp[n][m];</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;正楷&quot; size=3&gt;今日所学知识点–&lt;strong&gt;线性dp&lt;/strong&gt;&lt;/font&gt;&lt;br&gt;&lt;fo</summary>
      
    
    
    
    <category term="算法" scheme="http://bighuang.fun/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="http://bighuang.fun/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
